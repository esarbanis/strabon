<?xml version="1.0" encoding="UTF-8"?>
<beans  xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    	xsi:schemaLocation="http://www.springframework.org/schema/beans 
    						http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"
		xmlns:jaxws="http://cxf.apache.org/jaxws"
		jaxws:schemaLocation="http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd">

	<bean id="serverProperties" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="locations">
			<list>
				<value>WEB-INF/connection.properties</value>
			</list>
		</property>
	</bean>
  
	<bean id="capsBean" class="eu.earthobservatory.org.StrabonEndpoint.capabilities.CapabilitiesDelegateBean" destroy-method="destroy">
		<!-- specify which implementation of the Capabilities interface shall be used -->
		<!-- true : AutoDiscoveryCapabilities -->
		<!-- false: EndpointCapabilities -->
		<constructor-arg type="boolean">
            <value>true</value>
        </constructor-arg>
	</bean>
	
    <bean
        id="strabonBean"
        class="eu.earthobservatory.org.StrabonEndpoint.StrabonBeanWrapper"
        destroy-method="destroy">

        <constructor-arg type="java.lang.String" >
            <!-- Database name -->
            <value>${dbname}</value>
        </constructor-arg>

        <constructor-arg type="java.lang.String" >
            <!-- Username -->
            <value>${username}</value>
        </constructor-arg>

        <constructor-arg type="java.lang.String" >
            <!-- Password -->
	    <value>${password}</value>
        </constructor-arg>

        <constructor-arg type="int" >
            <!-- Port -->
            <value>${port}</value>
        </constructor-arg>

        <constructor-arg type="java.lang.String" >
            <!-- Database server -->
            <value>${hostname}</value>
        </constructor-arg>

        <constructor-arg type="boolean" >
            <!-- Check for locks and remove them (in case of a crash) -->
            <value>false</value>
        </constructor-arg>

        <constructor-arg type="java.lang.String" >
            <!-- Database Backend (either "postgis" or "monetdb") -->
            <value>${dbengine}</value>
        </constructor-arg>
        
        <constructor-arg type="int" >
            <!-- Query limit -->
            <value>1000</value>
        </constructor-arg>
        
        <constructor-arg type="java.lang.String" >
            <!-- Default prefixes -->
            <value><![CDATA[PREFIX lgd:<http://linkedgeodata.org/triplify/>
PREFIX lgdgeo:<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX lgdont:<http://linkedgeodata.org/ontology/>
PREFIX geonames:<http://www.geonames.org/ontology#>
PREFIX clc: <http://geo.linkedopendata.gr/corine/ontology#>
PREFIX gag: <http://teleios.di.uoa.gr/ontologies/gagKallikratis.rdf#>
PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#>
PREFIX dlr: <http://www.earthobservatory.eu/ontologies/dlrOntology-v2.owl#>
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
]]>
</value>
        </constructor-arg>
        
        <constructor-arg>
             <list>
             	<list>
             		<!-- Single valued elements correspond to headers -->
					<value>Discovery Queries</value>
	            </list>
				<list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>KML</value>   
	                <!-- Label -->
	                <value>[ΝΟΑ] Select all hotspots of 2012 before any refinement</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#> 
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#> 
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
PREFIX gag: <http://geo.linkedopendata.gr/greekadministrativeregion/ontology#>

SELECT ?h  (strdf:transform(?hGeo, <http://www.opengis.net/def/crs/EPSG/0/4326>) AS ?geo) ?conf ?municipality
WHERE { 
?h   noa:hasGeometry ?hGeo ;
     noa:hasAcquisitionTime ?hAcquisitionTime ; 
     noa:producedFromProcessingChain ?hProcessingChain ; 
     noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string ;
     noa:hasConfidence ?conf ;
     gag:hasMunicipality ?municipality .
     FILTER(?hProcessingChain = "DynamicThresholds" || ?hProcessingChain = "DynamicThresholds-TimePersistence") .
     FILTER("2012-05-01T00:00:00"^^xsd:dateTime <= ?hAcquisitionTime && ?hAcquisitionTime < "2012-10-01T00:00:00"^^xsd:dateTime ) .
     OPTIONAL {?h noa:isDiscarded ?disc }.
     FILTER (!bound(?disc)) .
}
]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value>map_local</value>
	            </list>
	            <list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>KML</value>   
	                <!-- Label -->
	                <value>[ΝΟΑ] Select all hotspots of 2012 after refinement operation 'delete in sea'</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX gag: <http://geo.linkedopendata.gr/greekadministrativeregion/ontology#>

INSERT {?h noa:isDiscarded "1"^^xsd:int ;
           noa:refinedBy noa:seaInconsistency .
} 
WHERE {
?h   noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime ;
     noa:producedFromProcessingChain "PROCESSING_CHAIN"^^xsd:string ;
     noa:isDerivedFromSensor "SENSOR"^^xsd:string .
       OPTIONAL {
    ?h	gag:hasMunicipality ?municipalit .
  } 
  FILTER(!bound(?municipality)) .
}	                ]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value>map_local</value>
	            </list>
	            <list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>KML</value>   
	                <!-- Label -->
	                <value>[ΝΟΑ] Select all hotspots of 2012 after refinement operation 'delete in inconsistent areas'</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#> 
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#> 
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?h (strdf:transform(?hGeo, <http://www.opengis.net/def/crs/EPSG/0/4326>) AS ?geo) ("Corine Land Cover inconsistency" as ?refinement)
WHERE { 
    ?h   noa:hasGeometry ?hGeo ;
         noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime ;
         noa:refinedBy noa:clcInconsistency .
}	                ]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value>map_local</value>
	            </list>
	            <list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>KML</value>   
	                <!-- Label -->
	                <value>[ΝΟΑ] Select all hotspots of 2012 after refinement operation 'refine in coast'</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#> 
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#> 
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?h (strdf:transform(?hGeo, <http://www.opengis.net/def/crs/EPSG/0/4326>) AS ?geo) ("Corine Land Cover inconsistency" as ?refinement)
WHERE { 
    ?h   noa:hasGeometry ?hGeo ;
         noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime ;
         noa:refinedBy noa:clcInconsistency .
}	                ]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value>map_local</value>
	            </list>
	            <list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>KML</value>   
	                <!-- Label -->
	                <value>[ΝΟΑ] Select all hotspots of 2012 after refinement operation 'refine according to time persistence'</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#> 
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#> 
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?h (strdf:transform(?hGeo, <http://www.opengis.net/def/crs/EPSG/0/4326>) AS ?geo) ("Temporal persistence" as ?refinement)
WHERE { 
    ?h   noa:hasGeometry ?hGeo ;
         noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime ;
         noa:refinedBy noa:temporalPersistence .
}	                ]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value>map_local</value>
	            </list>
	            <list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>KML</value>   
	                <!-- Label -->
	                <value>[NOA] Select all that have been refined by a refinement operation</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#>
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT (strdf:transform(?hGeo, <http://www.opengis.net/def/crs/EPSG/0/4326>) AS ?geo) (GROUP_CONCAT(?refinement; separator=", ") AS ?refinements)
WHERE { 
    ?h   noa:hasGeometry ?hGeo ;
         noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime ;
         noa:refinedBy ?refinement .
}
GROUP BY ?geo	                ]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value>map_local</value>
	            </list>	            
	            <list>
             		<!-- Single valued elements correspond to headers -->
					<value>Enrich available information</value>
	            </list>
				<list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>HTML</value>   
	                <!-- Label -->
	                <value>[NOA + GAG]Connect each hotspot with the municipality where it is located</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#>
PREFIX gag: <http://geo.linkedopendata.gr/greekadministrativeregion/ontology#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 

INSERT { ?h gag:hasMunicipality ?muni }
WHERE { 
SELECT ?h (SAMPLE(?mLabel) AS ?muni)
  WHERE {
	?h  rdf:type noa:Hotspot ;
		noa:hasGeometry ?hGeo ;
		noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string ;
		noa:producedFromProcessingChain "DynamicThresholds"^^xsd:string ;
        noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime.
	?m	rdf:type gag:Dhmos ;
		rdfs:label ?mLabel ;
		gag:hasGeometry ?mGeo .
	FILTER(strdf:intersects(?hGeo, ?mGeo)) .
  }  
  GROUP BY ?h
}]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value></value>
	            </list>
	            
	            <list>
             		<!-- Single valued elements correspond to headers -->
					<value>Increase accuracy with respect to underlying area</value>
	            </list>
				<list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>HTML</value>   
	                <!-- Label -->
	                <value>[NOA+GAG] Delete all hotspots that fall in the sea</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX gag: <http://geo.linkedopendata.gr/greekadministrativeregion/ontology#>

INSERT {?h noa:isDiscarded "1"^^xsd:int ;
           noa:refinedBy noa:seaInconsistency .
} 
WHERE {
?h   noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime ;
     noa:producedFromProcessingChain "DynamicThresholds"^^xsd:string ;
     noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string .
       OPTIONAL {
    ?h	gag:hasMunicipality ?municipality .
  } 
  FILTER(!bound(?municipality)) .
}
	                ]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value>plain</value>
	            </list>
	            <list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>HTML</value>   
	                <!-- Label -->
	                <value>[NOA+Coastline] Delete the part of polygons that fall in the sea</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#> 
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#> 
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
PREFIX gag: <http://geo.linkedopendata.gr/greekadministrativeregion/ontology#>


INSERT { ?h noa:isDiscarded "1"^^xsd:int . 
	    ?valid rdf:type noa:Hotspot ;
	    noa:hasConfidence ?conf ;
	    noa:hasGeometry ?dif ;
	    gag:hasMunicipality ?municipality ;
	    noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime ; 
	    noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string ;
	    noa:hasConfirmation noa:unknown ;
	    noa:producedFromProcessingChain "DynamicThresholds"^^xsd:string ; 
	    noa:isProducedBy noa:noa ;
	    noa:isDerivedFromSatellite "METEOSAT8"^^xsd:string ;
            noa:refinedBy noa:coastlineRefinement ;
            noa:refinedBy ?refined .
}
WHERE { 
  SELECT ?h  (strdf:intersection(?hGeo, strdf:union(?cGeo)) AS ?dif) (URI(CONCAT(STR(?h),"/refined")) AS ?valid) ?conf ?municipality
  WHERE { 
	 ?h     noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime; 
       		noa:producedFromProcessingChain "DynamicThresholds"^^xsd:string ; 
       		noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string ;
		noa:hasGeometry ?hGeo ;
       		gag:hasMunicipality ?municipality ;
       		noa:hasConfidence ?conf .
	 ?c     rdf:type gag:GeometryPart ;
       		gag:hasGeometry ?cGeo .
       	FILTER(strdf:mbbIntersects(?hGeo, ?cGeo)) . 
	OPTIONAL { ?h noa:refinedBy ?refined } .
  }
  GROUP BY ?h ?hGeo ?conf ?municipality
  HAVING strdf:overlap(?hGeo, strdf:union(?cGeo))
}	                ]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value></value>
	            </list>
	             <list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>HTML</value>   
	                <!-- Label -->
	                <value>[NOA+CLC] Delete all hotspots that intersect with inconsistent areas</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#> 
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#> 
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
PREFIX clc: <http://geo.linkedopendata.gr/corine/ontology#>

INSERT {?h noa:isDiscarded "1"^^xsd:int ;
           noa:refinedBy noa:clcInconsistency .
} 
WHERE {
	SELECT ?h WHERE 
	{
		?h  noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime ;
			noa:producedFromProcessingChain "PROCESSING_CHAIN"^^xsd:string ;
			noa:isDerivedFromSensor "SENSOR"^^xsd:string ;
			noa:hasGeometry ?hGeo.
		?a  rdf:type   clc:ExcludeArea;
			clc:hasGeometry ?aGeo.
		FILTER(strdf:mbbIntersects(?hGeo,?aGeo)).
	} 
	GROUP BY ?h ?hGeo
	HAVING strdf:contains(strdf:union(?aGeo),?hGeo)
}]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value>plain</value>
	            </list>
	            <list>
             		<!-- Single valued elements correspond to headers -->
					<value>Increase accuracy with respect to time persistence</value>
	            </list>
				<list>
	                 <!-- Bean -->
	                <value>Query</value> 
	                <!-- Format -->
	                <value>HTML</value>   
	                <!-- Label -->
	                <value>[NOA] Add virtual hotspots accoring to time persistence of actually detected hotspots</value> 
	                <!-- Statement -->
	                <value><![CDATA[PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#> 
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#> 
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
PREFIX gag: <http://geo.linkedopendata.gr/greekadministrativeregion/ontology#>

INSERT {?newHotspot rdf:type noa:Hotspot ;
		    noa:hasConfidence ?hConfidence ;
		    noa:hasGeometry ?hGeometry1 ;
		    noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime ; 
		    noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string ;
		    noa:hasConfirmation noa:unknown ;
		    noa:producedFromProcessingChain "DynamicThresholds-TimePersistence"^^xsd:string ; 
		    noa:isProducedBy noa:noa ;
		    gag:hasMunicipality ?hMunicipality1 ;
		    noa:isDerivedFromSatellite "METEOSAT8"^^xsd:string ;
                    noa:refinedBy noa:temporalPersistence ;
                    noa:refinedBy ?refined .
}
WHERE {
	SELECT  (URI(CONCAT(STR(MAX(?h1)),"/virtual/NEW_HOTSPOT")) AS ?newHotspot)
			(SUM(?hConfidence1)/ACQUISITIONS_IN_HALF_AN_HOUR AS ?hConfidence)
			?hGeometry1 ?hMunicipality1
  WHERE {
    ?h1 noa:hasConfidence ?hConfidence1 ;
        noa:hasGeometry ?hGeometry1 ;
        gag:hasMunicipality ?hMunicipality1 ;
        noa:hasAcquisitionTime ?hAcquisitionTime1 ;
        noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string ;
        noa:producedFromProcessingChain "DynamicThresholds"^^xsd:string .
    OPTIONAL { ?h1 noa:isDiscarded ?z } .
    FILTER (!BOUND(?z)) .
    OPTIONAL { ?h1 noa:refinedBy ?refined } .
    FILTER( "MIN_ACQUISITION_TIME"^^xsd:dateTime <= ?hAcquisitionTime1 && ?hAcquisitionTime1 < "TIMESTAMP"^^xsd:dateTime ) .
    OPTIONAL {
      ?h2 noa:hasGeometry ?hGeometry2 ;
          noa:hasAcquisitionTime "TIMESTAMP"^^xsd:dateTime ;
          noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string ;
          noa:producedFromProcessingChain ?hProcessingChain2 .
      FILTER(("DynamicThresholds"^^xsd:string = ?hProcessingChain2)||("DynamicThresholds-TimePersistence"^^xsd:string = ?hProcessingChain2)).
      FILTER( strdf:mbbEquals(?hGeometry1, ?hGeometry2) ) .
    }
    FILTER( !BOUND(?h2) ) .
  }
  GROUP BY ?hGeometry1 ?hMunicipality1
  HAVING(SUM(?hConfidence1)>0.0)
}]]></value>
	                <!-- Description -->
					<value></value>
					<!-- Hander (plain, download, map or map_local)-->
					<value>plain</value>
	            </list>

				<list>
             		<!-- Single valued elements correspond to headers -->
					<value>Explore/Modify operations</value>
	            </list>
	            <list>
             		<!-- Link to bean: two arguemnts -->
					<value>Store</value>
					<value>store.jsp</value>
	            </list>
	            <list>
             		<!-- Link to bean: two arguemnts -->
					<value>Query/Update</value>
					<value>query.jsp</value>
	            </list>
	            <list>
             		<!-- Link to bean: two arguemnts -->
					<value>Describe</value>
					<value>describe.jsp</value>
	            </list>
	            <list>
             		<!-- Link to bean: two arguemnts -->
					<value>Browse</value>
					<value>browse.jsp</value>
	            </list>
				<list>
					<!-- Link to bean: two arguemnts -->
					<value>Configuration</value>
					<value>ChangeConnection</value>
				</list>
            </list>
         </constructor-arg>
    </bean>
</beans>
