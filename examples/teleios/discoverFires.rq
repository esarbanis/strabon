#Το πρώτο query εφαρμόζεται  με σκοπό τον περιορισμό τoυ θορύβου,
#εντοπίζοντας την χρονική αστάθεια ("αναλαμπές") σε πολύγωνα
#καμένων εκτάσεων. Υλοποιήσαμε και εφαρμόσαμε το ακόλουθο  χρονικό φίλτρο
#στα δεδομένα (με αναφορές στον πηγαίο κώδικα):
#- Στις γραμμές 1574..1614, για κάθε πολύγωνο, ομαδοποιούμε τις
#καταγραφές οι οποίες δεν απέχουν μεταξύ τους (επόμενη-προηγούμενη)
#περισσότερο από την τιμή της μεταβλητής persistence.
#- Στην συνέχεια εξετάζουμε κάθε τέτοια ομάδα (κοντινών στο χώρο
#καταγραφών), και ελέγχουμε εάν το πλήθος τους (για κάθε τέτοια ομάδα)
#είναι μικρότερο ή ίσο από την τιμή της μεταβλητής repeat_in_persistence
#(γραμμές 1614..1630).
#- Αυτές τις καταγραφές τις διαγράφουμε θεωρώντας τις θόρυβο


PREFIX noa: <http://teleios.di.uoa.gr/ontologies/noaOntology.owl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX strdf: <http://strdf.di.uoa.gr/ontology#>
PREFIX strdf-ext: <http://strdf.di.uoa.gr/extensions/ontology#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX gag: <http://geo.linkedopendata.gr/greekadministrativeregion/ontology#>

SELECT ?hStartTime ?hMinEndTime ?geo
WHERE {
    ?h noa:hasGeometry ?geo.
    FILTER(?hStartTime <= ?hTime && ?hTime <= ?hMinEndTime).
    {
    SELECT ?hStartTime ?hMinEndTime ?hTime ?geo ?h 
    WHERE
    {
        ?h	noa:hasAcquisitionTime ?hTime ;
	        noa:producedFromProcessingChain "DynamicThresholds"^^xsd:string ;
         	noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string .
        FILTER("2012-07-26T00:00:00"^^xsd:dateTime <= ?hTime && ?hTime <= "2012-07-27T00:00:00"^^xsd:dateTime)

        {
            SELECT ?hStartTime (min(?hEndTime) as ?hMinEndTime) ?geo
            WHERE {
                # Retrieve all hotstpots in time range
                ?hStart	noa:hasAcquisitionTime ?hStartTime ;
                        noa:hasGeometry ?geo ;
                		noa:producedFromProcessingChain "DynamicThresholds"^^xsd:string ;
                     	noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string .
            FILTER("2012-07-26T00:00:00"^^xsd:dateTime <= ?hStartTime && ?hStartTime <= "2012-07-27T00:00:00"^^xsd:dateTime)

                # Filter hotspots whose previous hotspot has been detected at least PERSISTENCE msecs before
                OPTIONAL {
                    ?hPrevious	noa:hasAcquisitionTime ?hPreviousTime ;
                    			noa:hasGeometry ?geo ;
                            	noa:producedFromProcessingChain "DynamicThresholds"^^xsd:string ;
                        	 	noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string .
                    FILTER("2012-07-26T00:00:00"^^xsd:dateTime <= ?hPreviousTime && ?hPreviousTime <= "2012-07-27T00:00:00"^^xsd:dateTime)
                    FILTER( strdf-ext:diffDateTime(?hStartTime, ?hPreviousTime) <= "10"^^xsd:long && ?hStartTime > ?hPreviousTime).
                } 
                FILTER(!bound(?hPrevious)) .

                # Retrieve all hotstpots in time range
                ?hEnd	noa:hasAcquisitionTime ?hEndTime ;
                        noa:hasGeometry ?geo ;
                		noa:producedFromProcessingChain "DynamicThresholds"^^xsd:string ;
                     	noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string .
            FILTER("2012-07-26T00:00:00"^^xsd:dateTime <= ?hEndTime && ?hEndTime <= "2012-07-27T00:00:00"^^xsd:dateTime)

                # Filter hotspots whose next hotspot has been detected at least PERSISTENCE msecs after
                OPTIONAL {
                    ?hAfter	noa:hasAcquisitionTime ?hAfterTime ;
                    			noa:hasGeometry ?geo ;
                            	noa:producedFromProcessingChain "DynamicThresholds"^^xsd:string ;
                        	 	noa:isDerivedFromSensor "MSG1_RSS"^^xsd:string .
                    FILTER("2012-07-26T00:00:00"^^xsd:dateTime <= ?hAfterTime && ?hAfterTime <= "2012-07-27T00:00:00"^^xsd:dateTime)
                    FILTER( strdf-ext:diffDateTime(?hAfterTime, ?hEndTime) <= "10"^^xsd:long && ?hAfterTime > ?hEndTime).
                } 
                FILTER(!bound(?hAfter)) .

                FILTER(?hStartTime < ?hEndTime).  

                      
            }
            GROUP BY ?hStartTime ?geo
            ORDER BY ?hStartTime
        }.
    }
    }.
}
GROUP BY ?geo ?hStartTime ?hMinEndTime
HAVING (count(?h) > 0)
